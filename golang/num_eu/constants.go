package num_eu

import "math"

// block 1
//===========================================================

//   Константы

const (
	d_0    = float64(0.005)                    // [-] -> [nm]         обход нуля
	dr     = float64(1e-4)                     // [-] -> [nm]         шаг
	nx     = float64(32000)                    // [-]                 число точек разбиения
	e      = float64(-1.602 * 1e-19)           // [A*s]               заряд электрона
	k_Bolt = float64(1.38 * 1e-23)             // [J/K]               постоянная Больцмана
	eps0   = float64(8.85418781762039 * 1e-12) // [F*м^−1]            Диэлектрическая проницаемость вакуума
	one_eV = float64(1.602176620898 * 1e-19)   // [J]                 Один электронвольт
)

// слишком маленькие числа для функций numpy
//   Входные данные
var (
	temp float64 = 5.0  // [eV]                 температура
	R    float64 = 3.0  // [nm]                 радиус ионной сферы
	n_i  float64 = 27.6 // [nm−3]               плотность электронов: плотность ионов, умноженная на среднюю степень ионизации
)

//===================================================================================
// Входные данные в СИ

var (
	temp_SI float64 // [K]                 температура
	R_SI    float64 // [m]                 радиус ионной сферы
	n_i_SI  float64 // [m−3]               плотность электронов: плотность ионов, умноженная на среднюю степень ионизации
	l_Berum float64 // [m]                 длина Бьеррума/Ландау
	l_Deb   float64 // [m]                 длина Дебая
)

//==============================================================================================
// Внутренние единицы

var (
	rho1   float64 = 0.5 // [обзразмеренно на l_Deb-3]       концентрация(плотность) заряда ионов внутреняя(обезразмерянная и деленная на 2)
	rho2   float64 = 0   // [обзразмеренно на l_Deb-3]       концентрация(плотность) заряда ионов внешняя(вакуум)
	R1, R2 float64       // [обзразмеренно на l_Deb]          радиус ионной сферы
)

//==============================================================================================
// Инициализирующие функции

func init_SI() {
	temp_SI = temp * one_eV / k_Bolt
	R_SI = R * 1e-9
	n_i_SI = n_i * 1e27
	l_Berum = e * e / (4 * math.Pi * eps0 * k_Bolt * temp_SI)
	l_Deb = math.Sqrt((eps0 * k_Bolt * temp_SI) / (e * e * n_i_SI))
}

func Init_in_value(rho1_init, rho2_init, temp_init float64) {
	rho1 = rho1_init
	rho2 = rho2_init
	temp = temp_init
	init_SI()
	R1, R2 = R_SI/l_Deb, R_SI/l_Deb
}
